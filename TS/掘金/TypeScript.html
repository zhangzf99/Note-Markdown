<!DOCTYPE html>
<html>
<head>
<title>TypeScript.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="typescript">TypeScript</h1>
<h2 id="%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91">安装、编译</h2>
<pre class="hljs"><code><div>cnpm install -g typescript

tsc helloword.ts
</div></code></pre>
<pre class="hljs"><code><div>1、 tsc --init 生成tscconfig.json  改&quot;outDir&quot;:'./js'

2、vscode 任务-运行任务-监视
</div></code></pre>
<h2 id="%E8%BF%9B%E5%85%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%96%E7%95%8C%E7%90%86%E8%A7%A3%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">进入类型的世界：理解原始类型与对象类型</h2>
<h3 id="%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">原始类型的类型标注</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> name1: string = <span class="hljs-string">"zhangzf99"</span>;
<span class="hljs-keyword">const</span> age: number = <span class="hljs-number">10</span>;
<span class="hljs-keyword">const</span> bool: boolean = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> undef: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">const</span> nul: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> obj: object = { name1 };
<span class="hljs-keyword">const</span> bigint1: bigint = <span class="hljs-number">90909907986756746545n</span>;
<span class="hljs-keyword">const</span> bigint2: bigint = BigInt(<span class="hljs-number">90909907986756746545</span>);
<span class="hljs-keyword">const</span> symbolVar: symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"unique"</span>);
</div></code></pre>
<h3 id="null-%E5%92%8C-undefined">null 和 undefined</h3>
<p>在 js 中，null -&gt; 这里有值，但是个空值，undefined -&gt; 这里没有值
在 ts 中，null 和 undefined 类型都是有具体意义的类型。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 strictNullChecks 检查的情况下，会<strong>被视作其他类型的子类型</strong>，比如 string 类型会被认为包含了 null 与 undefined 类型：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> temp1: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> temp2: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">const</span> temp3: string = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 仅在关闭 strictNullChecks 时成立，下同</span>
<span class="hljs-keyword">const</span> temp4: string = <span class="hljs-literal">undefined</span>;
</div></code></pre>
<h3 id="void">void</h3>
<p>ts 的类型标注中也有 void，用于描述一个内部没有 return 语句，或者没有显示 return 一个值的函数的返回值。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func3</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
}
</div></code></pre>
<p>func1 与 func2 的返回值都会被隐式推导为 void，只有显示返回了 undefined 值的 func3 其返回值才会被推导为了 undefined。但在实际的代码执行中，func1 与 func2 的返回值均是 undefined。</p>
<pre class="hljs"><code><div>虽然 func3 的返回值类型会被推导为undefined，但是你仍然可以使用 void 类型进行标注，因为在类型层面 func1、func2、func3 都表示“没有返回一个有意义的值”。
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func3</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
}
</div></code></pre>
<h3 id="%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">数组的类型标注</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> arr1: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">"111"</span>, <span class="hljs-string">"222"</span>];
<span class="hljs-keyword">const</span> arr2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">111</span>, <span class="hljs-number">2</span>];
</div></code></pre>
<p>数组是我们在日常开发大量使用的数据结构，但在某些情况下，使用<strong>元组</strong>来代替数组更加妥当，比如一个数组中只存放固定长度的变量，但我们进行了超出长度的访问：</p>
<pre class="hljs"><code><div>console.log(arr1[999]); // undefined
</div></code></pre>
<p>这种是不符合预期的，因为我们能确定这个数组中只有三个成员，并希望在越界访问时给出类型报错。这时我们可以使用元组类型进行类型注释：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> arr3: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, <span class="hljs-literal">null</span>] = [<span class="hljs-string">"111"</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">null</span>];
<span class="hljs-built_in">console</span>.log(arr3[<span class="hljs-number">999</span>]); <span class="hljs-comment">// 报错 长度为 "3" 的元组类型 "[string, number, null]" 在索引 "999" 处没有元素。</span>
</div></code></pre>
<p>在这种情况下，对数组合法边界内的索引访问（即 0、1、2）将精准地获得对应位置上的类型。同时元组也支持了再某一位置上的可选成员：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> arr4: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>?, <span class="hljs-built_in">boolean</span>?] = [<span class="hljs-string">"111"</span>, <span class="hljs-number">11</span>];
<span class="hljs-comment">// 鼠标放在arr4上 const arr4: [string, (number | undefined)?, (boolean | undefined)?]</span>
<span class="hljs-built_in">console</span>.log(arr4.length); <span class="hljs-comment">// 2</span>
</div></code></pre>
<p>对于标记为可选的成员，在 --strictNullCheckes 配置下会被视为一个 string | undefined 的类型。此时数组长度属性也会发生变化，比如上面的元组 arr4， 其长度类型为 1 | 2 | 3。</p>
<p>可能会觉得元组的可读性实际上并不好。比如对于 [string, number, boolean]来说，你并不能直接知道这三个元素都代表什么，还不如使用对象的形式。在 ts4.0 中，有了具名元组的支持。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> arr5: [name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, male: <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">"zhangzf"</span>, <span class="hljs-number">18</span>, <span class="hljs-literal">true</span>];

<span class="hljs-comment">// 可选修饰符</span>
<span class="hljs-keyword">const</span> arr6: [name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>, male?: <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">"zhangzf"</span>, <span class="hljs-number">18</span>];
</div></code></pre>
<p>实际上除了显示地越界访问，还可能存在隐式地越界访问，如通过解构赋值的形式：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> arr7: <span class="hljs-built_in">string</span>[] = [];
<span class="hljs-keyword">const</span> [ele1, ele2, ...rest] = arr7;
</div></code></pre>
<p>对于数组，此时仍然无法检查出是否是否存在隐式访问，因为类型层面并不知道它到底有多少个元素。但对于数组，隐式的越界访问也能够被揪出来一个警告：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> arr8: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">"111"</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span>];
<span class="hljs-keyword">const</span> [name2, age2, male, other] = arr8; <span class="hljs-comment">// 长度为 "3" 的元组类型 "[string, number, boolean]" 在索引 "3" 处没有元素。</span>
</div></code></pre>
<h3 id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">对象的类型标注</h3>
<p>类似于数组类型，在 ts 中我们也需要特殊的类型标注来描述对象类型，即 interface，你可以理解为它代表了这个对象对外提供的接口结构。
首先我们使用 interface 声明了一个结构，然后使用这个结构作为一个对象的类型标注即可：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> IDescription {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
  male: <span class="hljs-built_in">boolean</span>;
}
<span class="hljs-keyword">const</span> obj1: IDescription = {
  name: <span class="hljs-string">"zhangzf"</span>,
  age: <span class="hljs-number">18</span>,
  male: <span class="hljs-literal">true</span>,
};
</div></code></pre>
<p>这里的“描述”指：</p>
<ul>
<li>每一个属性的值必须<strong>一一对应</strong>到接口的属性类型</li>
<li>不能有多的属性，也不能有少的属性，包括直接在对象内部声明，或是 obj1.other = 'xxx' 这样属性访问赋值的形式。</li>
</ul>
<p>除了声明属性以及属性的类型以外，我们还可以对属性进行修饰，常见的修饰包括<strong>可选</strong>与<strong>只读</strong>这两种。</p>
<h3 id="%E4%BF%AE%E9%A5%B0%E6%8E%A5%E5%8F%A3%E5%B1%9E%E6%80%A7">修饰接口属性</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> IDescription1 {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
  male?: <span class="hljs-built_in">boolean</span>;
  func?: <span class="hljs-built_in">Function</span>;
}
<span class="hljs-keyword">const</span> obj2: IDescription1 = {
  name: <span class="hljs-string">"zhangzf"</span>,
  age: <span class="hljs-number">18</span>,
  male: <span class="hljs-literal">true</span>,
};
</div></code></pre>
<p>假设新增一个可选的函数类型属性，然后进行调用：obj2.func()，此时将会产生一个类型报错：不能调用可能是未定义的方法。但可选属性标记不会影响你对这个属性进行赋值，如：</p>
<pre class="hljs"><code><div>boj2.male = <span class="hljs-literal">false</span>;
obj2.func = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {};
</div></code></pre>
<p>即使你对可选属性进行了赋值，TypeScript 仍然会使用<strong>接口的描述为准</strong>进行类型检查，你可以使用类型断言、非空断言或可选链解决。
除了标记一个属性为可选以外，你还可以标记这个属性为只读：readonly。很多同学对这一关键字比较陌生，因为以往 js 中并没有这一概念，它的作用是<strong>防止对象的属性被再次赋值</strong>。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> IDescription2 {
  readonly name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">const</span> obj3: IDescription2 = {
  name: <span class="hljs-string">"zhangzf"</span>,
  age: <span class="hljs-number">18</span>,
};
obj3.name = <span class="hljs-string">"zhangzf99"</span>; <span class="hljs-comment">// 无法分配到 "name" ，因为它是只读属性。</span>
</div></code></pre>
<p>其实在数组与元组层面也有着只读的修饰，但与对象类型有着两处不同。</p>
<ul>
<li>你只能将整个数组/元组标记为只读，而不能像对象那样标记某个属性为只读。</li>
<li>一旦被标记为只读，那这个只读数组/元组的类型上，将不再具有 push、pop 等方法（即会修改原数组的方法），因此报错信息也将是<strong>类型 xxx 上不存在属性“push”这种</strong>。这一实现的本质是<strong>只读数组与只读元组的类型实际上变成了 ReadyonlyArray，而不是 Array</strong>。</li>
</ul>
<h3 id="type-%E4%B8%8E-interface">type 与 interface</h3>
<p>interface 可以用来描述对象、类的结构
type 类型别名可以用来<strong>将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型</strong>。但大部分场景下接口都可以被类型别名所取代。</p>
<h3 id="unique-symbol">unique symbol</h3>
<p>Symbol 在 js 中代表着一个唯一的值类型，类似于字符串类型，可以作为对象的属性名，并用于避免错误修改 对象/Class 内部属性的情况。而在 ts 中，symbol 类型并不具有这一特性，一百个具有 symbol 类型的对象，它们的 symbol 类型指的都是 ts 中同一类型。为了实现“独一无二”的这个特性，ts 中支持了 unique symbol 这一类型声明，它是 symbol 类型的子类型，每一个 unique symbol 类型都是独一无二的。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> uniqueSymbolFoo: unique symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"zhangzf"</span>);
<span class="hljs-keyword">const</span> uniqueSymbolBar: unique symbol = uniqueSymbolFoo; <span class="hljs-comment">// 不能将类型“typeof uniqueSymbolFoo”分配给类型“typeof uniqueSymbolBar”。</span>
</div></code></pre>
<p>在 js 中，我们可以用 Symbol.for 方法来复用已创建的 Symbol，如 Symbol.for('zhangzf')会首先查找全局是否已经有使用 zhangzf 作为 key 的 Symbol 注册，如果有，则返回这个 Symbol，否则才会创建新的 Symbol。</p>
<h2 id="%E6%8E%8C%E6%8F%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9E%9A%E4%B8%BE%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%86%8D%E7%B2%BE%E7%A1%AE%E4%B8%80%E4%BA%9B">掌握字面量类型与枚举，让你的类型再精确一些</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> IRes {
  code: <span class="hljs-built_in">number</span>;
  status: <span class="hljs-built_in">string</span>;
  data: <span class="hljs-built_in">any</span>;
}
</div></code></pre>
<p>以上代码是一个接口结构，它描述了响应的消息结构，在大多数情况下，这里的 code 与 status 实际值会来自于一组确定值的集合，比如 code 可能是 10000 / 10001 / 50000，status 可能是 “success”/“failure”。而上面的类型只给出了一个宽泛的 number(string)，此时我们既不能在访问 code 时获得精确的提示，也失去了 ts 类型即文档的功能。</p>
<h3 id="%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B">字面量类型与联合类型</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> Res {
  code: <span class="hljs-number">10000</span> | <span class="hljs-number">10001</span> | <span class="hljs-number">50000</span>;
  status: <span class="hljs-string">"success"</span> | <span class="hljs-string">"failure"</span>;
  data: <span class="hljs-built_in">any</span>;
}
</div></code></pre>
<h3 id="%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B">字面量类型</h3>
<p>“success”是一个值，为什么可以作为类型？在 ts 中，这叫做字面量类型，它代表着比原始类型更精确的类型，同是也是原始类型的子类型。
字面量类型主要包括<strong>字符串字面量类型、数字字面量类型、布尔字面量类型、对象字面量类型</strong>，他们可以直接作为类型标注：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> str: <span class="hljs-string">"zhangzf"</span> = <span class="hljs-string">"zhangzf"</span>;
<span class="hljs-keyword">const</span> num: <span class="hljs-number">59</span> = <span class="hljs-number">59</span>;
<span class="hljs-keyword">const</span> bool1: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span>;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// 报错！不能将类型“"linbudu599"”分配给类型“"linbudu"”。</span>
<span class="hljs-keyword">const</span> str1: <span class="hljs-string">"linbudu"</span> = <span class="hljs-string">"linbudu599"</span>;

<span class="hljs-keyword">const</span> str2: <span class="hljs-built_in">string</span> = <span class="hljs-string">"linbudu"</span>;
<span class="hljs-keyword">const</span> str3: <span class="hljs-built_in">string</span> = <span class="hljs-string">"linbudu599"</span>;
</div></code></pre>
<p>上面的代码中，原始类型可以包括任意的同类型值，而字面量类型要求的是值级别的字面量一致。</p>
<p>单独使用字面量类型比较少见，因为单个字面量类型并没有什么实际意义。它通常和联合类型（即这里的 |）一起使用，表达一组字面量类型：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> Tmp {
  bool: <span class="hljs-literal">true</span> | <span class="hljs-literal">false</span>;
  num: <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>;
  str: <span class="hljs-string">"lin"</span> | <span class="hljs-string">"bu"</span> | <span class="hljs-string">"du"</span>;
}
</div></code></pre>
<h3 id="%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B">联合类型</h3>
<p>一组类型的可用集合，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型。联合类型对其成员并没有任何限制，除了上面这样对同一类型字面量的联合，还可以将各种类型混合到一起：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> Tmp {
  mixed: <span class="hljs-literal">true</span> | <span class="hljs-built_in">string</span> | <span class="hljs-number">599</span> | {} | <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params"></span>) =&gt; {}</span>) | (<span class="hljs-params">1 | 2</span>);
}
</span></div></code></pre>
<p><strong>注意</strong></p>
<ul>
<li>对于联合类型中的函数类型，需要使用 （）包裹起来</li>
<li>函数类型并不存在字面量类型，因此这里的 (()=&gt;{}) 就是一个合法的函数类型</li>
<li>你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会别展平到第一级中</li>
</ul>
<p>联合类型的常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性，即这一属性如果有字段 1，那就没有字段 2：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> Tmp1 {
  user:
    | {
        vip: <span class="hljs-literal">true</span>;
        expires: <span class="hljs-built_in">string</span>;
      }
    | {
        vip: <span class="hljs-literal">false</span>;
        promotion: <span class="hljs-built_in">string</span>;
      };
}
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> tmp: Tmp1;
<span class="hljs-keyword">if</span> (tmp.user.vip) {
  <span class="hljs-built_in">console</span>.log(tmp.user.expires);
}
</div></code></pre>
<p>在这个例子中，user 属性会满足普通用户与 vip 用户两种类型，这里 vip 属性的类型基于布尔字面量类型声明。我们在实际使用时可以通过判断此属性为 true，确保接下来的类型推导都会将其类型收窄到 vip 用户的类型（即联合类型的第一个分支）。这一能力的使用涉及类型守卫与类型控制流分析。</p>
<p>我们也可以通过类型别名来复用一组字面量联合类型：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> code = <span class="hljs-number">10000</span> | <span class="hljs-number">10001</span> | <span class="hljs-number">50000</span>;
<span class="hljs-keyword">type</span> status = <span class="hljs-string">"success"</span> | <span class="hljs-string">"failure"</span>;
</div></code></pre>
<h3 id="%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B">对象字面量类型</h3>
<p>类似的，对象字面量类型就是一个对象类型的值。当然，这也就意味着这个对象的值全都为字面量值：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> Tmp2 {
  obj: {
    name: <span class="hljs-string">"zhangzf"</span>;
    age: <span class="hljs-number">18</span>;
  };
}
<span class="hljs-keyword">const</span> tmp: Tmp2 = {
  obj: {
    name: <span class="hljs-string">"zhangzf"</span>,
    age: <span class="hljs-number">18</span>,
  },
};
</div></code></pre>
<p>如果要实现一个对象字面量类型，意味着完全的实现这个类型每一个属性的每一个值。对象字面量类型在实际开发中的使用较少，我们只需要了解。
总的来说，在需要更精确类型的情况下，我们可以使用字面量类型加上联合类型的方式，将类型从 string 这种宽泛的原始类型直接收窄到 ”resolved&quot; | &quot;pending&quot; | &quot;rejected&quot; 这种精确地字面量类型集合。
需要注意的是，无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值。它们在编译时同样会被擦除，同时也是被存储在内存中的类型空间而非值空间。
如果说字面量类型是对原始类型的进一步扩展（对象字面量类型使用较少），那么枚举在某些方面则可以理解为是对对象类型的扩展。</p>
<h3 id="%E6%9E%9A%E4%B8%BE">枚举</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> PageUrl {
  Home_Page_Url = <span class="hljs-string">"url1"</span>,
  Setting_Page_Url = <span class="hljs-string">"url2"</span>,
  Share_Page_Url = <span class="hljs-string">"url3"</span>,
}
<span class="hljs-keyword">const</span> home = PageUrl.Home_Page_Url;
</div></code></pre>
<p>这些常量被真正地<strong>约束在一个命名空间</strong>下。如果没有声明枚举的值，它会默认使用数字枚举，并且从 0 开始，以 1 递增。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Items {
  Foo,
  Bar,
  Baz,
}
</div></code></pre>
<p>在这个例子中，Items.Foo，Items.Bar，Items.Baz 的值依次是 0，1，2。</p>
<p>如果你只为某一个成员指定了枚举值，那么之前未赋值成员仍然会使用从 0 递增的方式，之后的成员则会开始从枚举值递增。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Items1 {
  <span class="hljs-comment">// 0</span>
  Foo,
  Bar = <span class="hljs-number">599</span>,
  <span class="hljs-comment">// 600</span>
  Baz,
}
</div></code></pre>
<p>在数字枚举中，你可以使用延迟求值的枚举值，比如函数：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> returnNum = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">100</span> + <span class="hljs-number">499</span>;
<span class="hljs-keyword">enum</span> Items2 {
  Foo = returnNum(),
  Bar = <span class="hljs-number">599</span>,
  Baz,
}
</div></code></pre>
<p>需要注意的是，延迟求值的枚举值是有条件的。<strong>如果你使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后，或者放在第一位</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Items3 {
  Baz,
  Foo = returnNum(),
  Bar = <span class="hljs-number">599</span>,
}
</div></code></pre>
<p>ts 中也可以同时使用字符串枚举值和数字枚举值：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Mixed {
  Num = <span class="hljs-number">599</span>,
  Str = <span class="hljs-string">"zhangzf"</span>,
}
</div></code></pre>
<p>枚举和对象的重要差异在于，<strong>对象是单向映射的</strong>，我们只能从键映射到键值。而<strong>枚举是双向映射的</strong>，即你可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">enum</span> Items4 {
  Foo,
  Bar,
  Baz,
}
<span class="hljs-keyword">const</span> fooValue = Items4.Foo; <span class="hljs-comment">// 0</span>
<span class="hljs-keyword">const</span> fooKey = Items[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 'Foo'</span>
</div></code></pre>
<h3 id="%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE">常量枚举</h3>
<p>常量枚举和枚举类似，只是其声明多了一个 const：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> Items5 {
  Foo,
  Bar,
  Baz,
}
<span class="hljs-keyword">const</span> fooValue1 = Items.Foo; <span class="hljs-comment">// 0</span>
</div></code></pre>
<p>它和普通枚举的差异主要在访问性与编译产物。对于常量枚举，你只能通过枚举成员访问枚举值（而不能通过值访问成员）。同时，在编译产物中并不会存在一个额外的辅助对象，对枚举成员的访问会被<strong>直接内联替换为枚举的值</strong>。</p>
<h2 id="%E5%87%BD%E6%95%B0%E4%B8%8E-class-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">函数与 Class 中的类型，详解函数重载与面向对象</h2>
<h3 id="%E5%87%BD%E6%95%B0">函数</h3>
<h4 id="%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D">函数的类型签名</h4>
<p>如果说变量的类型是描述了这个变量的值类型，那么函数的类型就是描述了<strong>函数入参类型与函数返回值类型</strong>，它们同样使用**<img class="emoji" alt="kissing" src="data:image/png;base64,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" />*的语法进行类型标注。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> name.length;
}
</div></code></pre>
<p>在函数类型中同样存在着类型推导。比如在这个例子中，可以不写返回值处的类型，它也能被正确推导为 number 类型。</p>
<p>在 js 中，我们称<strong>function name(){}<strong>这一声明函数的方式为</strong>函数声明</strong>。除了函数声明外，我们还可以通过<strong>函数表达式</strong>，即**const foo = function(){}**的形式声明一个函数。在表达式中进行类型声明的方式是这样的：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> foo1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> name.length;
};
</div></code></pre>
<p>我们也可以像对变量进行类型标注那样，对 foo 这个变量进行类型声明：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> foo2: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> name.length;
};
</div></code></pre>
<p>这里的**(name: string) =&gt; number<strong>看起来眼熟，它是 ES6 的重要特性之一：箭头函数。但在这里，它其实是 ts 中的</strong>函数类型签名**。而实际的箭头函数，我们的类型标注也是类似的：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> foo3 = (name: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> name.length;
};

<span class="hljs-keyword">const</span> foo4: <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> name.length;
};

<span class="hljs-keyword">type</span> FucnFoo = <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">const</span> foo5: FucnFoo = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> name.length;
};
</div></code></pre>
<p>如果只是为了描述这个函数的类型结构，我们甚至可以使用 interface 来进行函数声明：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> FuncFooStruct {
  (name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>;
}
</div></code></pre>
<h3 id="void-%E7%B1%BB%E5%9E%8B">void 类型</h3>
<p>在 ts 中，一个没有返回值（即没有调用 return 语句）的函数，其返回类型应当被标记为 void 而不是 undefined，即使它实际的值是 undefined。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo6</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">return</span>;
}
</div></code></pre>
<p>原因和我们在原始类型与对象类型一节中讲到的：在 ts 中，undefined 类型是一个实际的、有意义的类型值，而 void 才代表着空的、没有意义的类型值。因此在我们没有实际返回值时，使用 void 类型能更好地说明这个函数<strong>没有进行返回操作</strong>。但在上面的第二个例子中，其实更好的方式是使用 undefined：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar1</span>(<span class="hljs-params"></span>): <span class="hljs-title">undefined</span> </span>{
  <span class="hljs-keyword">return</span>;
}
</div></code></pre>
<p>此时该函数表达的是，这个函数进行了返回操作，但没有返回实际的值。</p>
<h3 id="%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E4%B8%8E-rest-%E5%8F%82%E6%95%B0">可选参数与 rest 参数</h3>
<p>在很多时候，我们会希望函数的参数可以更灵活，比如它不一定全部都必传，当你不传入参数时函数会使用此参数的默认值。正如在对象类型中我们使用**?<strong>描述一个可选属性一样，在函数类型中我们也使用</strong>?**描述一个可选参数：</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 在函数逻辑中注入可选参数默认值</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo7</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">const</span> inputAge = age || <span class="hljs-number">18</span>;
  <span class="hljs-keyword">return</span> name.length + inputAge;
}
<span class="hljs-comment">// 直接为可选参数声明默认值</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo8</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span> = 18</span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">const</span> inputAge = age;
  <span class="hljs-keyword">return</span> name.length + inputAge;
}
</div></code></pre>
<p>需要注意的是，<strong>可选参数必须位于必选参数之后</strong>。毕竟在 js 中函数的入参是按照位置（形参），而不是按照参数名（名参）进行传递。当然，我们也可以直接将可选参数与默认值合并，但此时就不能够使用**?**了，因为既然都有默认值，那肯定是可选参数了。</p>
<p>对于 rest 参数的类型标注也比较简单，由于其实际上是一个数组，这里我们也应当使用数组类型进行标注：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo10</span>(<span class="hljs-params">arg1: <span class="hljs-built_in">string</span>, ...rest: <span class="hljs-built_in">any</span>[]</span>) </span>{}

<span class="hljs-comment">// 使用元组类型进行标注</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo11</span>(<span class="hljs-params">arg1: <span class="hljs-built_in">string</span>, ...rest: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>]</span>) </span>{}
</div></code></pre>
<h3 id="%E9%87%8D%E8%BD%BD">重载</h3>
<p>在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">if</span> (bar) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(foo);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> foo * <span class="hljs-number">10</span>;
  }
}
</div></code></pre>
<p>在这个实例中，函数的返回类型基于其入参 bar 的值，并且从其内部逻辑中我们知道，当 bar 为 true，返回值为 string 类型，否则为 number 类型。而这里的类型签名完全没有体现这一点，我们只知道它的返回值是这么个联合类型。</p>
<p>要想实现与入参关联的返回值类型，我们可以使用 ts 提供的<strong>函数重载签名</strong>，将以上的例子使用重载改写：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar: <span class="hljs-literal">true</span></span>): <span class="hljs-title">string</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-literal">false</span></span>): <span class="hljs-title">number</span></span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span>, bar?: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">if</span> (bar) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(foo);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> foo * <span class="hljs-number">599</span>;
  }
}
<span class="hljs-keyword">const</span> res1 = func(<span class="hljs-number">599</span>); <span class="hljs-comment">// number</span>
<span class="hljs-keyword">const</span> res2 = func(<span class="hljs-number">599</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// string</span>
<span class="hljs-keyword">const</span> res3 = func(<span class="hljs-number">599</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// number</span>
</div></code></pre>
<p>这里我们的三个 function func1 其实具有不同的意义：</p>
<ul>
<li>function func(foo: number, bar: true): string，重载签名一，传入 bar 的值为 true 时，函数返回值为 string 类型。</li>
<li>function func(foo: number, bar?: false): number，重载签名二，不传入 bar，或传入 bar 的值为 false 时，函数返回值为 number 类型。</li>
<li>function func(foo: number, bar?: boolean): string | number，函数的实现签名，会包含重载签名的所有可能情况。</li>
</ul>
<p>基于重载签名，我们就实现了将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力。</p>
<p><strong>注意</strong>：拥有多个重载声明的函数再被调用时，是按照重载的什么顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型。</p>
<h3 id="%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0generator-%E5%87%BD%E6%95%B0%E7%AD%89%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D">异步函数、Generator 函数等类型签名</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">void</span>&gt; </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">void</span>&gt; </span>{}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">asyncGenFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">AsyncIterable</span>&lt;<span class="hljs-title">void</span>&gt; </span>{}
</div></code></pre>
<h3 id="class">Class</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> Foo {
  prop: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">this</span>.prop = inputProp;
  }

  print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.prop}</span> and <span class="hljs-subst">${addon}</span>`</span>);
  }

  <span class="hljs-keyword">get</span> propA(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.prop}</span>+A`</span>;
  }

  <span class="hljs-keyword">set</span> propA(value: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">this</span>.prop = <span class="hljs-string">`<span class="hljs-subst">${value}</span>+A`</span>;
  }
}
</div></code></pre>
<p><strong>注意</strong>：setter 方法不允许进行返回值的类型标注，可以理解为 setter 的返回值并不会被消费，它是一个只关注过程的函数。类的方法同样可以进行函数那样的重载，且语法基本一致。</p>
<p>就像函数可以通过<strong>函数声明</strong>与<strong>函数表达式</strong>创建一样，类也可以通过<strong>类声明</strong>和<strong>类表达式</strong>的方式创建。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> Foo1 = <span class="hljs-keyword">class</span> {
  prop: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">this</span>.prop = inputProp;
  }
  print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.prop}</span> and <span class="hljs-subst">${addon}</span>`</span>);
  }
};
</div></code></pre>
<h3 id="%E4%BF%AE%E9%A5%B0%E7%AC%A6">修饰符</h3>
<p>在 ts 中我们能够为 Class 成员添加这些修饰符: <strong>public / private / protected / readonly</strong>。除了 readonly 以外，其他都是属于访问性修饰符，而 readonly 属于操作性修饰符 （就和 interface 中的 readonly 意义一致）。
这些修饰符应用的位置在成员命名前：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> Foo {
  <span class="hljs-keyword">private</span> prop: <span class="hljs-built_in">string</span>;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">inputProp: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">this</span>.prop = inputProp;
  }

  <span class="hljs-keyword">protected</span> print(addon: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.prop}</span> and <span class="hljs-subst">${addon}</span>`</span>);
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> propA(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.prop}</span>+A`</span>;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">set</span> propA(value: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">this</span>.propA = <span class="hljs-string">`<span class="hljs-subst">${value}</span>+A`</span>;
  }
}
</div></code></pre>
<ul>
<li>public：此类成员在 <strong>类、类的实例、子类</strong> 中都能被访问。</li>
<li>private：此类成员仅能在<strong>类的内部</strong>被访问。</li>
<li>protected：此类成员仅能在<strong>类与子类中</strong>被访问，你可以将类和类的实例当做两种概念，即一旦实例化完毕，那就和类没有关系了，即<strong>不允许再访问受保护的成员</strong>。</li>
</ul>
<p>当你不显示使用访问性修饰符，成员的访问性默认会被标记为 public。实际上，在上面的例子中，我们通过构造函数为类成员赋值的方式还是略显麻烦，需要声明类属性以及在构造函数中进行赋值。简单起见，我们可以<strong>在构造函数中对参数应用访问性修饰符</strong>。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo5</span> </span>{
  <span class="hljs-keyword">constructor</span>(public arg1: string, private arg2: boolean) {}
}
<span class="hljs-keyword">new</span> Foo5(<span class="hljs-string">"zhangzf"</span>, <span class="hljs-literal">true</span>);
</div></code></pre>
<p>此时，参数会被直接作为类的成员（即实例的属性），免去后续的手动赋值。</p>
<h3 id="%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态成员</h3>
<p>在 ts 中，可以使用 static 关键字来标识一个成员为静态成员：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> Foo6 {
  <span class="hljs-keyword">static</span> staticHandle() {}
  <span class="hljs-keyword">public</span> instanceHandle() {}
}
</div></code></pre>
<p>不同于实例成员，在类的内部静态成员无法通过 this 来访问，需要通过 Foo.staticHandle 这种形式进行访问。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> Foo = <span class="hljs-comment">/** @class */</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>{}
  Foo.staticHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
  Foo.prototype.instanceHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};
  <span class="hljs-keyword">return</span> Foo;
})();
</div></code></pre>
<p>从上述代码中可以看到，<strong>静态成员直接被挂载在函数体上，而实例成员被挂载在原型上</strong>。这就是二者最重要的差异：<strong>静态成员不会被实例继承，它始终只属于当前定义的这个类（以及其子类）</strong>。而原型对象上的实例成员则会<strong>沿着原型链进行传递</strong>，也就是能够被继承。</p>
<h3 id="%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB">继承、实现、抽象类</h3>
<p>与 js 一样，ts 中也使用 extends 关键字实现继承。</p>
<pre class="hljs"><code><div>calss Base{}
<span class="hljs-keyword">class</span> Derived <span class="hljs-keyword">extends</span> Base{}
</div></code></pre>
<p>对于这两个类，比较严谨的称呼是<strong>基类</strong>与<strong>派生类</strong>。
基类中的哪些成员可以被派生类访问，完全是由其访问性修饰符决定的。派生类中可以访问到使用 public 或 protected 修饰符的基类成员。除了访问以外，基类中的方法也可以在派生类中被覆盖，但是可以通过 super 访问到基类中的方法。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> Base {
  print() {}
}
<span class="hljs-keyword">class</span> Derived <span class="hljs-keyword">extends</span> Base {
  print() {
    <span class="hljs-keyword">super</span>.print();
  }
}
</div></code></pre>
<h3 id="%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</h3>
<p>抽象类是对类结构与方法的抽象，简单来说，<strong>一个抽象类描述了一个类中应当有哪些成员（属性、方法等），一个抽象方法描述了这一方法在实际实现中的结构</strong>。我们知道类的方法和函数非常相似，包括结构，因此抽象方法其实描述的就是这个方法的<strong>入参类型</strong>与<strong>返回值类型</strong>。</p>
<p>抽象类使用 abstract 关键字声明：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> AbsFoo {
  <span class="hljs-keyword">abstract</span> absProp: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">get</span> absGetter(): <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">abstract</span> absMethod(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
}
</div></code></pre>
<p>注意，抽象类中的成员也需要使用 abstract 关键字才能被视为抽象类成员，如这里的抽象方法。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> Foo12 <span class="hljs-keyword">implements</span> AbsFoo {
  absProp: <span class="hljs-built_in">string</span> = <span class="hljs-string">"zhangzf"</span>;
  <span class="hljs-keyword">get</span> absGetter() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"zhangzf"</span>;
  }
  absMethod(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> name;
  }
}
</div></code></pre>
<p>此时，我们必须完全实现这个抽象类的每一个抽象成员。需要注意的是，在 ts 中<strong>无法声明静态的抽象成员</strong>。</p>
<p>对于抽象类，它的本质就是描述类的结构。看到结构，你是否又想到了 interface？是的，interface 不仅可以声明函数结构，也可以声明类的结构：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> FooStruct {
  absProp: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">get</span> absGetter(): <span class="hljs-built_in">string</span>;
  absMethod(input: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">class</span> Foo7 <span class="hljs-keyword">implements</span> FooStruct {
  absProp: <span class="hljs-built_in">string</span> = <span class="hljs-string">"linbudu"</span>;

  <span class="hljs-keyword">get</span> absGetter() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"linbudu"</span>;
  }

  absMethod(name: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">return</span> name;
  }
}
</div></code></pre>
<p>在这里，使用类去实现了一个接口。这里接口的作用和抽象类一样，都是<strong>描述这个类的结构</strong>。</p>
<h2 id="%E6%8E%A2%E7%A7%98%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8Banyunknownnever-%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">探秘内置类型：any、unknown、never 与类型断言</h2>
<h3 id="any">any</h3>
<h4 id="%E4%BD%BF%E7%94%A8-any-%E7%9A%84%E5%9C%BA%E6%99%AF">使用 any 的场景</h4>
<ul>
<li>如果是类型不兼容报错导致使用 any ，考虑使用类型断言替代。</li>
<li>如果是类型太复杂导致使用 any ，考虑将这一处的类型去断言为你需要的最简类型。</li>
<li>如果想要表达一个未知类型，可以使用 unknown。</li>
</ul>
<h4 id="known">known</h4>
<p>unknown 类型和 any 类型有点类似，一个 unknown 类型的变量可以再次赋值为任意其他类型，但只能赋值给 any 与 unknown 类型的变量。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> unknownVar: unknown = <span class="hljs-string">"linbudu"</span>;

unknownVar = <span class="hljs-literal">false</span>;
unknownVar = <span class="hljs-string">"linbudu"</span>;
unknownVar = {
  site: <span class="hljs-string">"juejin"</span>,
};

unknownVar = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {};

<span class="hljs-keyword">const</span> val1: <span class="hljs-built_in">string</span> = unknownVar; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">const</span> val2: <span class="hljs-built_in">number</span> = unknownVar; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">const</span> val3: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {} = unknownVar; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">const</span> val4: {} = unknownVar; <span class="hljs-comment">// Error</span>

<span class="hljs-keyword">const</span> val5: <span class="hljs-built_in">any</span> = unknownVar;
<span class="hljs-keyword">const</span> val6: unknown = unknownVar;
</div></code></pre>
<p>unknown 和 any 的一个主要差异体现在赋值给别的变量时，any 放弃了所有的类型检查，而 unknown 没有。这一点也体现在对 unknown 类型的变量进行属性访问时：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> unknownVar: unknown;
unknownVar.foo(); <span class="hljs-comment">// 报错：对象类型为 unknown</span>
</div></code></pre>
<p>要对 unknown 类型进行属性访问，需要进行类型断言，即“虽然这是一个未知的类型，但是我跟你保证它在这里就是这个类型”。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> unknownVar: unknown;
<span class="hljs-function">(<span class="hljs-params">unknownVar <span class="hljs-keyword">as</span> { foo: (<span class="hljs-params"></span>) =&gt; {} }</span>).<span class="hljs-params">foo</span><span class="hljs-params">()</span>;
</span></div></code></pre>
<p>在类型未知的情况下，更推荐使用 unknown 标注。这相当于使用额外的心智负担保证了类型再各处的结构，后续重构为具体类型时也可以获得最初始的类型信息，同时还保证了类型检查的存在。</p>
<h3 id="never">never</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> UnionWithNever = <span class="hljs-string">"linbudu"</span> | <span class="hljs-number">599</span> | <span class="hljs-literal">true</span> | <span class="hljs-built_in">void</span> | never;
</div></code></pre>
<p>鼠标悬浮在类型别名上，会发现显示的类型时&quot;linbudu&quot; | 599 | true | void。
never 类型被直接无视掉了，而 void 仍然存在。这是因为，void 作为类型表示一个空类型，就像没有返回值的函数使用 void 来作为返回值类型标注一样，void 类型就像 js 中的 null 一样代表“这里有类型，但是是个空类型”。</p>
<p>而 never 才是一个“什么都没有”的类型，它甚至不包括空的类型，严格来说，<strong>never 类型不携带任何的类型信息</strong>，因此会在联合类型中被直接移除，比如我们看 void 和 never 的类型兼容性：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> v1: never;
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> v2: <span class="hljs-built_in">void</span>;
v1 = v2; <span class="hljs-comment">// X 类型void不能赋值给类型never</span>
v2 = v1;
</div></code></pre>
<p>在编程语言的类型系统中，never 类型被称为 Bottom Type，是<strong>整个类型系统层级中最底层的类型</strong>。和 null 和 undefined 一样，它是所有类型的子类型，但只有 never 类型的变量能够赋值给另一个 never 类型变量。</p>
<p>通常我们不会显示的声明一个 never 类型，它主要被类型检查所使用。但在某些情况下使用 never 是符合逻辑的，比如一个只负责抛出错误的函数：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">justThrow</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();
}
</div></code></pre>
<h3 id="%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E8%AD%A6%E5%91%8A%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E5%87%86%E6%8A%A5%E9%94%99">类型断言：警告编译器不准报错</h3>
<p>类型断言能够显示告知类型检查程序当前这个变量的类型，可以进行类型分析的修正类型。它其实就是一个将变量的已有类型更改为新指定类型的操作，它的基本语法是 as NewType，你可以将 any/unknown 类型断言到一个具体的类型：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> unknownVar: unknown;
<span class="hljs-function">(<span class="hljs-params">unknownVar <span class="hljs-keyword">as</span> { foo: (<span class="hljs-params"></span>) =&gt; {} }</span>).<span class="hljs-params">foo</span><span class="hljs-params">()</span>;
</span></div></code></pre>
<p>还可以 as 到 any 来，跳过所有的类型检查：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">"zhangzf"</span>;
(str <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).func().foo().prop;
</div></code></pre>
<p>也可以在联合类型中断言一个具体的分支：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">union: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>{
  <span class="hljs-keyword">if</span> ((union <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).includes(<span class="hljs-string">"linbudu"</span>)) {
  }

  <span class="hljs-keyword">if</span> ((union <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>).toFixed() === <span class="hljs-string">"599"</span>) {
  }
}
</div></code></pre>
<p>断言的正确使用方式，在 ts 类型分析不正确或不符合预期时，将其断言为此处的正确类型：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> IFoo {
  name: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> obj: {
  foo: IFoo;
};
<span class="hljs-keyword">const</span> { foo = {} <span class="hljs-keyword">as</span> IFoo } = obj;
</div></code></pre>
<p>这里从 {} 字面量类型断言为了 IFOO 类型，即为结构赋值默认值进行了预期的类型断言。当然，更严谨的方式应该是定义为 Partial<IFoo> 类型，即 IFoo 的属性均为可选。
除了使用 as 语法以外，也可以使用 &lt;&gt; 语法。
需要注意的是，类型断言应当是在迫不得已的情况下使用的。虽然说我们可以用类型断言纠正不正确的类型分析，但类型分析在大部分场景下还是可以满足我们的需求的。</p>
<h3 id="%E5%8F%8C%E9%87%8D%E6%96%AD%E8%A8%80">双重断言</h3>
<p>如果在使用类型断言时，原类型与断言类型之间差异过大，ts 会给一个类型报错。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">"linbudu"</span>;

<span class="hljs-function">(<span class="hljs-params">str <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> { handler: (<span class="hljs-params"></span>) =&gt; {} }</span>).<span class="hljs-params">handler</span><span class="hljs-params">()</span>;

// 使用尖括号断言
(<span class="hljs-params">&lt;{ handler: (<span class="hljs-params"></span>) =&gt; {} }&gt;(<span class="hljs-params">&lt;unknown&gt;str</span>)</span>).<span class="hljs-params">handler</span><span class="hljs-params">()</span>;
</span></div></code></pre>
<p>这是因为断言类型和原类型的差异太大，需要先断言到一个通用的类，即 any/unknown。这一通用类型包含了所有可能的类型，因此<strong>断言到它</strong>和<strong>从它断言到另一个类型</strong>差异不大。</p>
<h3 id="%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80">非空断言</h3>
<h2 id="%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%A5%BD%E5%B8%AE%E6%89%8B-ts-%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7%E4%B8%8A">类型编程好帮手： ts 类型工具（上）</h2>
<h3 id="%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D">类型别名</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> A = <span class="hljs-built_in">string</span>;
</div></code></pre>
<p>通过 type 关键字声明了一个类型别名 A，同时它的类型等价于 string 类型。类型别名的作用主要是对一组类型或一个特定类型结构进行封装，以便于在其他地方进行复用。</p>
<p>比如抽离一组联合类型：</p>
<pre class="hljs"><code><div>
</div></code></pre>

</body>
</html>
